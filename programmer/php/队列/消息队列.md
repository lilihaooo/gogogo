## 消息队列

**一、消息对列概念**

从本质上说消息对列就是一个队列结构的中间件，也就是说**消息放入这个中间件之后就可以直接返回，并不需要系统立即处理**，而另外会有一个程序读取这些数据，并按顺序进行逐次处理。



**二、结构**

![img](https://pic1.zhimg.com/80/v2-adb478ea3d9ae32bd0538f7dd8c643b0_720w.webp)

由一个业务系统进行入队，把消息逐次插入到消息队列中，**插入成功之后直接返回成功的结果**，后续会有一个消息处理系统，这个系统会把消息系统中的记录逐次进行取出并进行处理，完成一个出队的流程。





**三、应用场景**

```text
1、数据冗余：比如订单系统，后续需要严格的进行数据转换和记录，消息队列可以把这些数据持久化的存储在队列中，然后有订单，后续处理程序进行获取，后续处理完之后在把这条记录进行删除来保证每一条记录都能够处理完成。

2、系统解耦：使用消息系统之后，入队系统和出队系统是分开的，也就说其中一个崩溃之后不会影响另外一个的正常运行。

3、异步通信：消息本身使用入队之后可以直接返回。

4、扩展性：例如订单队列，不仅可以处理订单，还可以给其他业务使用。

5、排序保证：有些场景需要按照产品的顺序进行处理比如单进单出从而保证数据按照一定的顺序处理，使用消息队列是可以的。

6、流量削峰：就是秒杀和抢购的时候，会出现明显的流量剧增，对服务器的压力非常大。 

7、消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。
```

**四、队列介质**

```text
1、数据库，例如mysql（可靠性高，易实现，速度慢）
2、缓存， 例如redis（速度快，单个消息报包过大时效率低）
3、消息系统，专业性强，可靠，学习成本高（例如rabbitMq是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。） 
4、Beanstalkd （一个高性能、轻量级的分布式内存队列系统）
```

**五、消息处理触发机制**

```text
1、死循环方式读取：易实现，故障时无法及时恢复；（比较适合做秒杀，比较集中，运维集中维护）

2、定时任务：压力均分，有处理上限；目前比较流行的处理触发机制。（唯一的缺点是间隔和数据需要注意，不要等上一个任务没有完成下一个任务又开始了）

3、守护进程：类似于php-fpm 和php-cg,需要shell基础

4、采用发布订阅的方式
```

**六、案例一：应用解耦**

　　应用解耦：在订单系统出现故障时，不会影响到物流系统

```text
一、说明：电商系统中订单系统、物流系统、财务系统以及操作日志记录系统之间的关系。

二、注意点：需要考虑中间数据的容灾能力，当故障发生并恢复时，保证业务流程可以恢复。保证每条数据都可以正确地完成处理。

三、传统模式：订单系统调用库存系统的接口。
       缺点：1）假如物流系统无法访问，则订单无法调用物流接口，从而导致订单失败； 
　　　　　　　2) 订单系统与库存系统耦合

四、架构设计（以订单系统、物流系统为例，mysql为队列介质） 
1、首先订单系统会接收用户的订单，然后进行订单的处理。 
2、然后会把这些订单信息写到队列表中，这个队列表是沟通这两个系统的关键。 
3、由配送系统定时执行的一个程序来读取队列表进行处理。 
4、配送系统处理之后，会把已处理的记录进行标记。
```

![img](https://pic4.zhimg.com/80/v2-64c07400b1568e69d3adef49db20ad5f_720w.webp)

![img](https://pic4.zhimg.com/80/v2-062e1131fc746b36d4b10cd8ae9b8e67_720w.webp)

**主要是对消息队列的认识和能用来干什么的描述，看完后也能对消息队列有个清晰的认知。**





