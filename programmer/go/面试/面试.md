逃逸分析:

如果将函数内部变量的指针返回, 这个局部变量的作用域就超出了该函数, go编译器将会堆每个局部变量进行逃逸分析, 就会将内存分配到堆上, 而不是栈上.





go语言中所有的传参都是值传递:

参数如果是非引用类型(int, string, struct等), 这样就在函数中无法修改原来的内容; 如果是引用类型(指针, map, slice, chan等), 就可以修改原数据.





defer 先入后出



### make 和new的区别?

make和new是内置函数不是关键字.

变量初始化:

* 变量声明 var   var 声明值变量的时候, 系统会默认为他分配内存空间, 并赋零值
* 内存分配 make / new   如果声明**指针类型**或者**引用类型**的变量, 系统不会为他分配内存, 默认为nil. 此时不能直接使用, 否则会报错. 要使用new/ make分配内存地址后才能使用.

#### 使用场景区别:

 make:

* 只能用来分配或者初始化slice, map, chan的数据类型

new:

* 可以分配任意数据类型, 并设置零值



#### 返回值区别:

make:

* make 只初始化slice, map, chan这三种数据类型, 而且他们都是引用类型,就直接返回他们本身的类型, 没必要返回他们的指针

new:

* 返回一个指向该类型内存地址的指针





#### slice为什么不是线程安全的?

##### 线程安全的定义:

* 多个线程访问同一个对象时, 调用这个对象的行为都可以获得正确的结果, 那么这个对象就是线程安全的
* 若有多个线程同时执行写操作, 一般都需要考虑线程同步, 否则就可能影响线程安全.

##### 实现线程安全的几种方式:

1. 互斥锁
2. 读写锁
3. 原子操作
4. sync.once
5. sync.atomic
6. channel

slice底层结构并没有使用加锁的方式, 不支持并发读写, 所以并不是线程安全的, 使用多个goroutine对类型为slice的变量进行操作, 每次输出的大概率的都不一样, 与预期值不一致; slice在并发进行中并不会报错, 但是数据会丢失.







#### Map遍历是无序的.

要想有序: 先对map的key进行排序

#### Map为什么不是线程安全的?

不为了小部分情况(并发访问), 导致大部分程序付出加锁代价(性能), 决定不支持, 线程安全.

多个协程同时读写, 报错.

#### Map想实现线程安全(并发访问):

* 使用读写锁 map + sync.RWMutex
*  使用Go提供的sync.Map

#### Map冲突的解决方式:









#### goroutine泄露:

go协程数量不断增加, 就是goroutine泄露

排查:

​	单个函数:使用runtime.NumGoroutine方法打印 执行代码前后的Goroutine的数量, 进行前后比较

​	生成/测试环境L使用PProf实时监测Goroutine的数量.

pprof 可以实时监测正在执行的goroutine的数量.









#### 排查go性能问题:

* to tool trace/ godebug   这段时间有没有异常
* go tool pproff 看那个函数消耗的cpu比较高, 内存高













## 内存分配

go 的内存是自主管理的

* 每个线程都会维护一个独立的内存池, 进行内存分配时优先从该内存池中分配, 当内存次不足时才会想加锁的全局内存中申请, 减少系统调用并且不同线程对全局内存池的锁竞争
* 把内存切分的非常细小, 分为多级管理, 以降低锁的粒度
* 回收对象内存时, 并没有将其真正的释放掉, 只是放回预先分配的大块内存中, 以便复用. 只有内存闲置过多的时候, 才会尝试归还部分内存给操作系统, 以降低整体开销







## 垃圾回收机制

GC 是回收的堆上的内存,  多线程共享内存

栈上的内存在函数执行完成后自动销毁.



#### 组成:

* 复制器
* 回收器



#### 主流算法

* 引用计数: 为每个对象维护一个引用计数, 当引用该对象的对象销毁时, 引用计数-1, 当对象引用计数为0时, 回收该对象
  * python, php, swift
  * 有点: 对象回收快, 不会出现内存消耗或达到某个阀值时才回收
  * 缺点: 不能很好处理循环引用, 而实时维护引用计数也是有消耗的
* 分代收集: 按照对象生命周期长短划分不同的代空间, 生命周期长的放入老年代, 短的放入新生代, 不同代有不同代的回收算法和回收频率
  * java
  * 优点: 回收性能好
  * 缺点: 算法复杂
* 标记-清除: 从根变量开始遍历所有的引用的对象, 标记引用的对象, 没有标记的进行回收
  * golang  三色标记法
  * 优点: 解决了引用计数的缺点
  * 缺点: 需要STW, 暂时停掉程序运行.



#### 触发GC

* 主动
  * runtime.GC()
* 定时触发
  * runtime.forcegcperiod变量控制, 默认为2分钟. 当超过2分钟没有产生任何GC时, 触发GC
  * 根据内存分配阈值触发, 该触发条件由变量GOGC控制, 默认值100(100%), 当堆内存是上次GC结束后的占用内存的2倍时, 触发



#### GC调优

* 控制内存分配速度, 限制goroutine的数量, 提高复制器mutator的CPU利用率(降低GC的cpu利用率)
* 少量食用+连接string
* slice提前分配足够的空间来降低扩容带来的拷贝
* 避免map key对象过多, 导致扫描时间增加
* 变量复用, 减少对象分配, 例如使用sync.Pool来复用需要频繁创建的临时对象, 使用全局变量等
* 增大GOGC的值, 降低GC频率







## 并发:

#### 线程间的通信方式: 

* 共享内存
* 消息传递

#### 常用的并发模型

* 共享内存并发模型
* CSP模型(发送消息)

=========================================================================================================







1. #### Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量

Golang中Goroutine 可以通过 **Channel** 进行安全读写共享变量,还可以通过**原子性操作**进行. **锁**

















