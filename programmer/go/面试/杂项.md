# go

 无缓冲channel 需要先读取，再写入，不然会死锁，所以加到goroutine里写，先阻塞挂起，让后面的读取先执行.







#### 上下文

 当上下文被关闭后，Done()返回{}，取消阻塞:

```
case x := <-ctx.Done(): 会取消阻塞
```





#### 锁

互斥锁:同一时间一个资源只能有一个goroutine访问. 

```
var mutex sync.Mutex
```

读写锁:

总的来说，就是写的时候不允许读和多个写，读的时候不允许写但是允许多个读，读和写不能同时进行。

```
var mutex sync.RWMutex
```

* RLock() 叫读锁。它不是绝对锁，比起互斥锁有着更高的并行性，它允许多个读者同时读取, 不能写。

* Lock() 叫写锁，它是个绝对锁，就是说，如果一旦某人拿到了这个锁，别人就不能再获取此锁了,不能读写。





#### channel

* for range 遍历管道前一定要关闭管道, 不然会阻塞

* for range 只有在管道被取空且被close时 for循环才会退出, 不然会一直阻塞

* 已经关闭的chan 且 取空了, 就取出零值 ok为false

  ```
  x, ok := <-chan
  ```

* 创建channel实际上就是在内存中实例化了一个`hchan`的结构体，并返回一个ch指针, channel本身就是一个指针
* 







#### 定时器, 打点器

定时器 是当你想要在未来某一刻执行一次时使用的
打点器 则是当你想要在固定的时间间隔重复执行准备的。这里是一个打点器的例子，它将定时的执行，直到我们将它停止。



#### 进程

并发: 一个cpu多个线程在同时轮询着(时间片切换的方式)同时进行, 切换是有成本的

并行: 多个cpu对多个线程同时计算





#### GMP调度器

G: goroutine协程

P: processor处理器  通过GOMAXPROCS设置, P的数量也就是最大的并行数

M: thread线程 操作系统分配到当前go程序的内核线程数量 M的最大量是10000(一般达不到, 忽略, 也可以设置), 动态的数量

![image-20221219225956768](C:\Users\86132\AppData\Roaming\Typora\typora-user-images\image-20221219225956768.png)







#### make和new的区别:

make是用来初始化切片, map, channel的

new 初始化stuct , 对象的返回它的指针时使用





#### 容器的并发安全性

数组, slice, struct允许并发修改(可能会脏读), 并发修改map时会发生panic(加锁, 分段), 如果要并发修改map使用sync.Map





