## HTTP协议  (超文本传输协议)

HTTP 是一个 client-server 协议(通信协议), 应用层协议

HTTP 依赖于面向连接的 TCP 进行消息传递，但连接并不是必须的。



在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。**HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接**。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。



为了减轻这些缺陷，HTTP/1.1 引入了**流水线**（被证明难以实现）**和持久连接的概念**：底层的 TCP 连接可以通过[`Connection`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)头部来被部分控制。HTTP/2 则发展得更远，通过在一个**连接复用消息**的方式来让这个连接始终**保持为暖连接**。







#### HTTP 能控制什么?

* [缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching) 文档如何缓存能通过 HTTP 来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
* *开放同源限制* 为了防止网络窥听和其它隐私泄漏，浏览器强制对 Web 网站做了分割限制。只有来自于**相同来源**的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP 可以通过修改头部来开放这样的限制，因此 Web 文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。
* *认证* 一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过 HTTP 提供，使用[`Authenticate`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authenticate)相似的头部即可，或用 HTTP Cookies 来设置指定的会话。
* *[代理和隧道](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling)* 通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS 协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。
* *会话* 使用 HTTP Cookies 允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的 HTTP 是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。





#### HTTP流

当客户端想要和服务端进行信息交互时（服务端是指最终服务器，或者是一个中间代理），过程表现为下面几步：

* 打开一个 TCP 连接
* 发送一个 HTTP 报文：HTTP 报文（在 HTTP/2 之前）是语义可读的。在 HTTP/2 中，这些简单的消息被封装在了帧中，这使得报文不能被直接读取，但是原理仍是相同的。
* 读取服务端返回的报文信息
* 关闭连接或者为后续请求重用连接。

当 HTTP 流水线启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。然而 HTTP 流水线已被证明很难在现有的网络中实现，因为现有网络中有很多老旧的软件与现代版本的软件共存。因此，**HTTP 流水线已被在有多请求下表现得更稳健的 HTTP/2 的帧所取代**。







#### HTTP报文

HTTP/1.1 以及更早的 HTTP 协议报文都是语义可读的。

 HTTP/2 中，这些报文被嵌入到了一个新的二进制结构，帧

​	帧允许实现很多优化，比如报文头部的压缩和复用
