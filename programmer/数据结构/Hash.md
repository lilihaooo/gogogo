## 散列表 Hash Table

散列表用的是数组支持按照**下标随机访问数据的**特性，所以散列表其实就是**数组的一种扩展**，由数组演化而来。可以说，如果没有数组，就没有散列表。



数组的下标形成一一映射，所以利用数组支持根据下标随机访问的时候，时间复杂度是 O(1)



散列表用的就是**数组支持按照下标随机访问**的时候，时间复杂度是 **O(1)** 的特性。我们通过**散列函数把元素的键值映射为下标**，然后将数据存储在数组中对应下标的位置。当我们**按照键值查询**元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。



 #### 散列函数

是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值

1. 散列函数计算得到的散列值是一个非负整数；

2. 如果 key1 = key2，那 hash(key1) == hash(key2)；

3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

   

#### 散列冲突

(

​	md5其实也是会重复的, 就是hash碰撞

​	Md5 128位, 可以存放2^128个数据  2^128 +1就冲突了. 鸽巢原理

)

再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，**开放寻址法**（open addressing）和**链表法**（chaining）。



#### 解决散列冲突

* 探测(开放寻址)(线性寻址)
  * 如果经过hash函数后生成了, 重复的值, 就顺延到下一个  (换到下一个没有被占用的鸽巢)
  * 元素被删除后标记delete, 不会移动数据
* 链表  JDK1.7
  * 插入, 删除容易
  * 查询慢 
    * 链表+红黑树JDK1.8  解决查找慢(当链表长度超过8时转为红黑树)





HashMap

​	线程不安全

​	不能存储大数据





## Hash算法

定义:任意长度的二进制值串**映射为固定长度的二进制值串**，这个**映射的规则**就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

* 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
* 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
* 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
* 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。



MD5 就是一种哈希算法





#### 应用

哈希算法的应用非常非常多，我选了最常见的七个，分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。