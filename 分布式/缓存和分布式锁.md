## 缓存与分布式锁

#### 哪些数据适合放进缓存

1. 即时性, 数据一致性要求不高的
2. 访问量大且更新不频繁的数据



#### 高并发时缓存失效的几个问题

* 缓存穿透
  * 描述:  (恶意)查询一个不存在的数据, 会导致大量请求直接到达数据库
  * 解决: 将不存在的值也写入缓存 (null), 同时加上一个短暂的**过期时间**  

* 缓存雪崩
  * 描述: 我们的大量缓存key, 设置了相同的过期时间, 导致缓存再某一时刻同时失效, 大量请求到达DB 
  * 解决: 给过期时间加上一个随机值, 比如1-5min的随机值.
* 缓存击穿
  * 描述: 对于热点数据, 如果key在高并发请求来之前刚好失效, 还没有来得及建立新的缓存, 则所有的请求就会到达DB
  * 解决: 加锁, 只允许一个请求查询, 其他请求等待, 查到了释放锁, 其他请求再获取锁, 获得锁后先查询缓存, 再查DB





#### 分布式锁

原理: redis中, 如果没有一个key(锁), 就set, 有就不能set

避免死锁: 加过期时间

由于业务时间过长, 本进程设置的锁过期, 我们再执行删锁时就会把其他进程设置的锁删除 解决: 为锁设置uuid, 判断后删除

如果判断是当前值, 正要删除的时候, 别人已经设置了新值, 那么我们还是删除的别人的锁 解决: 删除锁必须保持原子性(使用redis + Lua脚本)



##### redis 分布式锁

GO: Redsync

PHP: Redlock-php

看门狗: 

​	业务没运行完,能够对锁的过期时间自动续期, 避免提前解锁和解锁不及时. 

​	业务运行完成后可以手动解锁, 即使不手动解锁也可以在默认时间后自动删除

要是加锁时自己定义了过期时间, 看门狗功能失效, 过期时间为设置的时间



##### 读写锁

目的: 保证能读到最新数据, 

写锁: 互斥锁, 排他锁. 读锁: 共享锁

写 + 读: 读等待写释放

写 + 写: 阻塞

读 + 写: 等待读锁释放

读 + 读: 无锁, 并发读, 所有进程的读锁都会加锁成功





##### 锁的粒度

解释: 锁的名字, 越细越快

product-131-lock 锁定131号商品



##### 锁的一致性(update)

* 双写模式

  * 数据库改了再改缓存

    脏写(加锁)

    可以短暂允许数据不一致(设置过期时间, 然后从新更新缓存)

* 失效模式

  * 数据库改了, 删除缓存

    

注意: 要是对数据的实时性要求很高, 又是经常修改的数据就不要使用缓存, 避免频繁加锁影响性能.



解决方案:

1. 如果时用户维度(订单数据, 用户数据), 这种并发几率非常小(一个用户不可能同一时间提交很多个请求), 不用过多考虑这个问题: 缓存数据加上过期时间, 每隔一段时间主动更新.
2. 如果是商品介绍, 菜单等基础数据, 也可以使用cannl订阅binlog的方式
3. 通过加锁 -- 使得并发(无序的访问变成有序)

