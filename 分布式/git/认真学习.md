## Git

#### 时光穿梭

git init  创建本地厂库

git add 添加到暂存区

​	可以添加全部 git add . 

​	可以添加一个, 且可以多次添加

git commit 将暂存区中的文件提交到本地厂库

```
git commit -m "做了什么操作"
```

git status 显示状态

​	修改了没有add

​	add了没有提交

​	干净的

git diff

```
git diff 文件名
```

可以查看该文件做了什么样的修改



git log 查看历史提交 显示每次提交的信息

```
git log --pretty=oneline   //只显示每次提交的id和描述
```





git reset 版本回退

```
git reset -- hard HEAD^     //HEAD表示当前版本, HEAD^表示上一般本, HEAD^^表示上上版本 HEAD~100上100个版本  //HEAD类似一个指针
```

回退后再用 git log 会丢失本次提交后面的版本, 要想恢复就要找到后面的提交ID:

```
git reset --hard 1094a
```

要是找不到了提交ID了:

git reflog  记录每一次命令, 在这里面去找commit id



工作区:我电脑改目录下能看到的目录



版本库: Pepository  .git

​	主要内容:

​		 暂存区, 

​		 git为我们自动创建的第一个分支master

​		 指向master的指针HEAD





git checkout  --文件名    **撤销工作区的修改**

​	上次操作为add, 又修改了文件, 就撤销到add前	

​	上次操作为commit, 又修改了文件 , 就撤销到commit前

​	一定要有 -- , 不然语义发生该变: **切换到某个分支上**

​	git checkout 其实就是用版本库(暂存区, 或者分支上)的版本替换工作区中的版本, 无论是修改还是删除, 都可以一键还原)



想把add后的文件回退到工作区:

也使用: git reset HEAD  \<file>

`git reset`**命令既可以回退版本，也可以把暂存区的修改回退到工作区**



#### 回退的场景:

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库。





删除文件

rm 目录中的文件后

git status   会提示有文件被删除了

两种做法

	1. git rm 文件名
	1. git checkout --文件名  //就会用分支中的文件恢复到工作区, 完成对文件的恢复





#### 远程厂库:

Git是**分布式**版本控制系统，**同一个Git仓库，可以分布到不同的机器上**。

怎么分布呢?

最早, 肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。

实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他**每个人都从这个“服务器”仓库克隆一份到自己的电脑上**，并**且各自把各自的提交推送到服务器仓库里**，也从服**务器仓库中拉取别人的提交**。

如果你**不想让别人看到Git库**，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。



#### 使用远程仓库进行代码托管:

​	**先有本地库，后有远程库的时候，如何关联远程库**:

1. 要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；
   * 关联一个远程库时必须给远程库指定一个名字，`origin`是默认习惯命名；

2. 关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；
   * 加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。

3. 此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；

   

##### 克隆:

假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。

```
git clone git@github.com:michaelliao/gitskills.git
```

如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了

使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。

Git支持多种协议，包括`https`，但`ssh`协议速度最快。





#### 分支管理

分支就是科幻电影里面的**平行宇宙**，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，**两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！**

分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。



##### 创建分支与合并

Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即`master`分支。`HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。

一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点

当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上



git checkout -b dev 创建dev并将HEAD切换到dev分支上,    -b代表切换分支.  这命令相当于:

```
git branch dev
git checkout dev
```

git branch 查看分支

在这条分支上开展工作后, 切换到master分支上->

合并分支:

git merge dev    合并指定分支到当前分支

合并完成后删除dev分支:

git branch -d dev



switch

我们注意到切换分支使用`git checkout <branch>`，而前面讲过的撤销修改则是`git checkout -- <file>`，同一个命令，有两种作用，确实有点令人迷惑。

实际上，切换分支这个动作，用`switch`更科学。因此，最新版本的Git提供了新的`git switch`命令来切换分支：

创建并切换到新的`dev`分支，可以使用：

```
git switch -c dev
```

直接切换都已有分支

```
git switch master
```







##### 解决冲突

当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。

用`git log --graph`命令可以看到分支合并图。





git stash   把当前工作现场“储藏”起来，等以后恢复现场后继续工作

git stash list 查看储藏的列表

恢复:

1. git stash apply   恢复后，stash内容并不删除 用git stash drop来删除
2. git stash pop, 恢复同事删除stash





#### 多人协作, 推送分支

当你从远程仓库克隆时，实际上Git自动把本地的`master`分支和远程的`master`分支对应起来了，并且，远程仓库的默认名称是`origin`。

就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上

```
git push origin master  //推送本地分支master到远程分支master上

git push origin dev     //推送本地分支dev到远程分支dev上
```

不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？

- `master`分支是主分支，因此要时刻与远程同步；
- `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。





当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的`master`分支。不信可以用`git branch`命令看看：

现在，你的小伙伴要在`dev`分支上开发，就必须创建远程`origin`的`dev`分支到本地，于是他用这个命令创建本地`dev`分支：

```
git checkout -b dev origin/dev
```

现在，他就可以在`dev`上继续修改，然后，时不时地把`dev`分支`push`到远程：

你的小伙伴已经向`origin/dev`分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：

推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用`git pull`把最新的提交从`origin/dev`抓下来，然后，在本地合并，解决冲突，再推送：

`git pull`也失败了，原因是没有指定本地`dev`分支与远程`origin/dev`分支的链接，根据提示，设置`dev`和`origin/dev`的链接：

```
git branch --set-upstream-to=origin/dev dev
```

再pull：

这回`git pull`成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的[解决冲突](http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344)完全一样。解决后，提交，再push：

因此，**多人协作的工作模式通常是这样**：

1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；
2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；
3. 如果合并有冲突，则解决冲突，并在本地提交；
4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。

这就是多人协作的工作模式，一旦熟悉了，就非常简单。





#### 标签管理

发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。

Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。

Git有commit，为什么还要引入tag？

所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。





##### 使用标签:

首先切换到该分支上

git tag v1.0就打好了一个标签

git tag  查看所有的标签

```
git tag v0.9 f52c633  //指定某次提交并打上标签
```

```
$ git tag -a v0.1 -m "version 0.1 released" 1094adb   //-a标签名字  -m说明文字
```

git tag -d v1.0  删除标签

因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。

如果要推送某个标签到远程，使用命令`git push origin <tagname>`：

或者，一次性推送全部尚未推送到远程的本地标签:

```
git push origin --tags
```



如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：

```
git tag -d v0.9
```

然后，从远程删除。删除命令也是push，但是格式如下：

```
git push origin :refs/tags/v0.9
```